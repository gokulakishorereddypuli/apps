<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Task Notifier Pro</title>
    <style>
        :root { --primary: #2563eb; --danger: #ef4444; --bg: #f8fafc; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: var(--bg); margin: 0; padding: 20px; display: flex; justify-content: center; }
        .app-card { width: 100%; max-width: 450px; background: white; padding: 25px; border-radius: 16px; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }
        h2 { margin-top: 0; color: #1e293b; font-size: 1.5rem; }
        .input-group { display: flex; flex-direction: column; gap: 12px; margin-bottom: 25px; }
        input { padding: 12px; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 1rem; outline: none; }
        input:focus { border-color: var(--primary); ring: 2px var(--primary); }
        button { padding: 12px; border-radius: 8px; border: none; font-weight: 600; cursor: pointer; transition: opacity 0.2s; }
        .btn-add { background: var(--primary); color: white; }
        .btn-delete { background: #fee2e2; color: var(--danger); padding: 6px 12px; font-size: 0.85rem; }
        .task-list { border-top: 1px solid #f1f5f9; }
        .task-item { display: flex; justify-content: space-between; align-items: center; padding: 15px 0; border-bottom: 1px solid #f1f5f9; }
        .task-name { font-weight: 500; color: #334155; display: block; }
        .task-time { font-size: 0.85rem; color: #64748b; }
    </style>
</head>
<body>

<div class="app-card">
    <h2>My Schedule</h2>

    <div class="input-group">
        <input type="text" id="taskName" placeholder="Task description...">
        <input type="datetime-local" id="taskTime">
        <button class="btn-add" onclick="addTask()">Add Task & Enable Alerts</button>
    </div>

    <div id="taskList" class="task-list"></div>
</div>

<script>
    let tasks = JSON.parse(localStorage.getItem('mobileTasks')) || [];

    // Persisted "already notified" flags so refresh doesn't re-alert
    let notified = JSON.parse(localStorage.getItem('mobileNotified')) || {
        atTime: {},   // { [taskId]: true }
        tenMin: {}    // { [taskId]: true }
    };

    // Keep timer handles so we can cancel/reschedule cleanly
    const timers = new Map(); // taskId -> { atTimeTimeoutId, tenMinTimeoutId }

    // Request permission on first interaction
    async function requestNotifyPermission() {
        if (!("Notification" in window)) return false;
        const permission = await Notification.requestPermission();
        return permission === "granted";
    }

    function saveNotified() {
        localStorage.setItem('mobileNotified', JSON.stringify(notified));
    }

    function saveTasks() {
        localStorage.setItem('mobileTasks', JSON.stringify(tasks));
        renderTasks();
        rescheduleAll();
    }

    function clearAllTimers() {
        for (const { atTimeTimeoutId, tenMinTimeoutId } of timers.values()) {
            if (atTimeTimeoutId) clearTimeout(atTimeTimeoutId);
            if (tenMinTimeoutId) clearTimeout(tenMinTimeoutId);
        }
        timers.clear();
    }

    function scheduleTaskNotifications(task) {
        if (!("Notification" in window)) return;

        const now = Date.now();
        const msUntilStart = task.startTime - now;
        const msUntilTenMin = task.startTime - (10 * 60 * 1000) - now;

        if (!timers.has(task.id)) {
            timers.set(task.id, { atTimeTimeoutId: null, tenMinTimeoutId: null });
        }
        const entry = timers.get(task.id);

        // Optional: 10 minutes before
        if (msUntilTenMin > 0 && !notified.tenMin[task.id]) {
            entry.tenMinTimeoutId = setTimeout(() => {
                if (notified.tenMin[task.id]) return;

                new Notification(`Upcoming: ${task.name}`, {
                    body: `Starts in 10 minutes`,
                    tag: `tenmin-${task.id}`,
                    renotify: false,
                    silent: false
                });

                notified.tenMin[task.id] = true;
                saveNotified();
            }, msUntilTenMin);
        }

        // Real-time notification at exact task time
        if (msUntilStart > 0 && !notified.atTime[task.id]) {
            entry.atTimeTimeoutId = setTimeout(() => {
                if (notified.atTime[task.id]) return;

                new Notification(`Now: ${task.name}`, {
                    body: `Itâ€™s time to start.`,
                    tag: `attime-${task.id}`,
                    renotify: false,
                    silent: false
                });

                notified.atTime[task.id] = true;
                saveNotified();
            }, msUntilStart);
        }
    }

    function rescheduleAll() {
        clearAllTimers();

        // Cleanup notification flags for tasks that no longer exist
        const ids = new Set(tasks.map(t => String(t.id)));
        for (const k of Object.keys(notified.atTime)) if (!ids.has(String(k))) delete notified.atTime[k];
        for (const k of Object.keys(notified.tenMin)) if (!ids.has(String(k))) delete notified.tenMin[k];
        saveNotified();

        // Schedule future tasks
        tasks.forEach(task => {
            if (task.startTime <= Date.now()) return;
            scheduleTaskNotifications(task);
        });
    }

    async function addTask() {
        const nameInput = document.getElementById('taskName');
        const timeInput = document.getElementById('taskTime');

        if (!nameInput.value || !timeInput.value) {
            alert("Please fill in all fields");
            return;
        }

        const hasPermission = await requestNotifyPermission();
        if (!hasPermission) {
            alert("Notifications are not allowed. Please enable them in browser settings.");
            // You can still keep the task even if notifications are blocked.
        }

        const newTask = {
            id: Date.now(),
            name: nameInput.value,
            startTime: new Date(timeInput.value).getTime()
        };

        tasks.push(newTask);

        // reset flags for this task
        notified.atTime[newTask.id] = false;
        notified.tenMin[newTask.id] = false;
        saveNotified();

        saveTasks();

        // Immediate confirmation
        if (hasPermission) {
            new Notification("Task Scheduled", {
                body: `"${newTask.name}" scheduled for ${new Date(newTask.startTime).toLocaleString()}`,
                icon: "https://cdn-icons-png.flaticon.com/512/190/190411.png",
                tag: `added-${newTask.id}`,
                renotify: false
            });
        }

        nameInput.value = '';
        timeInput.value = '';
    }

    function deleteTask(id) {
        tasks = tasks.filter(t => t.id !== id);

        // cleanup notified flags + timers
        delete notified.atTime[id];
        delete notified.tenMin[id];
        saveNotified();

        saveTasks();
    }

    function renderTasks() {
        const container = document.getElementById('taskList');
        container.innerHTML = tasks.length === 0
            ? '<p style="color:#94a3b8; text-align:center;">No upcoming tasks</p>'
            : '';

        tasks
            .slice()
            .sort((a, b) => a.startTime - b.startTime)
            .forEach(t => {
                const div = document.createElement('div');
                div.className = 'task-item';
                div.innerHTML = `
                    <div>
                        <span class="task-name">${t.name}</span>
                        <span class="task-time">${new Date(t.startTime).toLocaleString()}</span>
                    </div>
                    <button class="btn-delete" onclick="deleteTask(${t.id})">Delete</button>
                `;
                container.appendChild(div);
            });
    }

    // Initial render + scheduling
    renderTasks();
    rescheduleAll();
</script>

</body>
</html>
